\chapter{Implementácia}
\label{chap:implementation}

V~tejto kapitole predstavíme triedy a popíšeme implementačné detaily jednotlivých častí algoritmu.

Budeme sa venovať základným triedam, riešeniam elementárnych vecí, detailom spacovania obrazu, rozpoznávaniu ruky a gesta. Podrobne si popíšeme implementáciu neurónových sietí.

Spomenieme aj niektoré problémy a ich riešenia a možnosti paralelizácie.

\bigskip

\section{Neurónové siete}

Naša implementácia neurónových sietí kopíruje vrstvový model. Základnou jednotkou je spojitý perceptrón, skupinu perceptrónov zastrešuje vrstva a skupinu vrstiev neurónová sieť. 

Ku každej z~týchto úrovní máme všeobecnú triedu a rôzne implementácie. Na obrázku \ref{fig:nnclsdiag} je class diagram nášho riešenia.

\begin{figure}[htp]
    \centering
    \includegraphics[width=\textwidth]{images/nn_class_diagram}
    \caption{Neurónové siete - Class diagram}
    \label{fig:nnclsdiag}
\end{figure}

\subsection{Perceptron}
\label{sect:perceptron}
\textit{Perceptron} je abstraktná trieda, ktorá zovšeobecňuje rôzne typy perceptrónov, ktoré sa líšia rôznymi aktivačnými funkciami.

Obsahuje trénovací algoritmus pre perceptróny
%(metóda \method{void train(vector<float> input,int target)} )
, ale aj podporu algoritmu \textit{backpropagation} 
%(metóda \method{ void trainDelta(vector<float> input, float delta)} )
a klasifikačný algoritmus 
%(metóda \method{ float classify(vector<float> input)} )
. Okrem toho obsahuje užitočné funkcie na randomizáciu váh, ukladanie a načítanie váh.

Perceptron pri volaní metód, ktoré majú ako parameter vstup siete si perceptrón sám pridá \textit{bias}
%TODO referenciu?
, takže ho nie je nutné pridávať k~vstupu.

Možnosť vytvorenia rôznych typov perceptrónov zabezpečujú abstraktné metódy 
\begin{itemize}
\item \method{float activationFunction(const vector<float>* input)},
\item \method{float derivativeFunction(float x)},
\end{itemize}
ktoré treba definovať.

\subsubsection{Dôležité metódy}
\begin{itemize}
\item \method{void train(vector<float> input,int target)}
\\Jednoduché trénovanie perceptrónov.
\\ \underline{Vstup:} \textit{input} - vstup siete, \textit{target} - požadovaný výstup 
%\\ \underline{Výstup:} \textit{void}
\item \method{ void trainDelta(vector<float> input, float delta)}
\\Delta trénovanie pre \textit{backpropagation} algoritmus.
\\ \underline{Vstup:} \textit{input} - vstup siete, \textit{delta} $=\delta$ z~učiaceho pravidla: $\Delta w_i = \alpha\delta x_i$\footnote{používame mierne inú notáciu ako je v~\cite{haykin1999neural}} \cite[s. 74]{haykin1999neural}
%\\ \underline{Výstup:} \textit{void}
\item \method{ float classify(vector<float> input)}
\\Klasifikačný algoritmus.
\\ \underline{Vstup:} \textit{input} - vstup siete
\\ \underline{Výstup:} reálne číslo z~intervalu $(0,1)$ - výstup siete.
\item \method{void prepare(vector<float>* input);}
\\Predpríprava vstupu pre spracovanie v~perceptróne - pridáva \textit{bias}.

Túto metódu treba volať tam, kde metóda dostáva užívateľský vstup - bez \textit{biasu}.
\\ \underline{Vstup:} \textit{*input} - pointer vstup siete
\\ \underline{Výstup:} metóda upraví priamo vektor, ktorý jej bol daný ako vstup.
\end{itemize}

\subsection{ContinuousPerceptron}
Trieda \textit{ContinuousPerceptron} je implementácia spojitého perceptrónu. Dedí od triedy \textit{Perceptron} 
Definuje aktivačnú funkciu
$$f(x)=\frac{1}{1+e^{-x}} $$
a jej deriváciu
$$f'(x)=\frac{e^x}{(e^x+1)^2} $$

\subsection{RecurrentPerceptron}
Trieda \textit{RecurrentPerceptron} rozširuje triedu \textit{ContinuousPerceptron} o~rekurentný vstup a metódy na manipulovanie s~ním -- \method{void update()} a \method{void reset()} na update a reset rekurentného vstupu.

\subsection{NeuralLayer}
\textit{NeuralLayer} je trieda, ktorá zoskupuje spojité perceptróny do vrstvy. Umožňuje trénovanie na viacrozmerné výstupy a podporuje \textit{backpropagation} algoritmus. 

Táto trieda poskytuje základnú implementáciu -- predkladá celý vstup každému neurónu. Je zároveň základnou triedou pre vrstvy neurónov, od ktorej potom dedia iné typy vrstiev. Zmena vlastností triedy sa deje v~konštruktore, kde je možné určiť typy jednotlivých neurónov a ich parametre.

\subsubsection{Dôležité metódy}
\begin{itemize}
\item \method{float train(vector<float> input, vector<int> target)}
\\Jednoduché trénovanie jednotlivých perceptrónov.
\\ \underline{Vstup:} \textit{input} - vstup siete, \textit{target} - požadované výstupy 
\\ \underline{Výstup:} chyba na danom vstupe.
\item \method{void trainDelta(vector<float> input,vector<float> delta)}
\\Delta trénovanie pre \textit{backpropagation} algoritmus.
\\ \underline{Vstup:} \textit{input} - vstup siete, \textit{delta} -- delty pre jednotlivé neuróny - podobne ako v~kapitole \ref{sect:perceptron}
%\\ \underline{Výstup:} \textit{void}
\item \method{ vector<float> classify(vector<float> input)}
\\ Klasifikačný algoritmus.
\\ \underline{Vstup:} \textit{input} - vstup siete
\\ \underline{Výstup:} pole čísel z~intervalu $(0,1)$ - výstup siete.
\end{itemize}

\subsection{DistributedNeuralLayer}
Trieda \textit{DistributedNeuralLayer} dedí od triedy \textit{NeuralLayer}. Poskytuje podobnú funkcionalitu ako \textit{NeuralLayer}, ale vstup je rozdelený na $n\times m$ častí a každý neurón má k~dispozícii len jednu časť. 

Okrem konštruktora bolo v~tomto prípade nutné upraviť aj metódy \method{float train(vector<float>,vector<int>)} a \method{vector<float> classify(vector<float>)}, tak, aby trénovanie a klasifikácia prebiehala na príslušnej časti vstupu.

\subsection{RecurrentLayer}
Trieda \textit{RecurrentLayer} dedí od triedy \textit{NeuralLayer}. Namiesto spojitých perceptrónov používa rekurentné. Navyše pridáva metódy \method{void update()} a \method{void reset()}, ktoré umožnujú update a reset rekurentného vstupu neurónov.

\subsection{DistributedRecurrentLayer}
Trieda \textit{DistributedRecurrentLayer} dedí od triedy \textit{RecurrentLayer} a \textit{DistributedRecurrentLayer}. Tu sa ukazuje sila nášho objektovo orientovaného modelu ako aj sila viacnásobného dedenia v~C++. Táto trieda obsahuje len konštruktor, ktorý volá konštruktory rodičovských tried. Prakticky bez námahy vieme takto vytvoriť nový typ siete spojením dvoch existujúcich.

Spojením dvoch typov vrstiev získavame máme nový typ vrstvy, ktorá obsahuje rekurentné neuróny, pričom každý z~nich má k~dispozícii len časť vstupu.

\subsection{NeuralNetwork}
Trieda \textit{NeuralNetwork} zoskupuje vrstvy do viacvrstvovej siete. Implementuje viacvrstvovú sieť s~vrstvami typu \textit{NeuralLayer} a zároveň slúži ako základná trieda pre neurónové siete, od ktorej potom dedia ostatné siete.

Poskytuje implementáciu \textit{backpropagation} algoritmu, ukladanie a načítanie váh do/zo súboru. 

Dediace triedy väčšinou mierne menia architektúru napríklad použitím iného typu vrstvy. Tieto zmeny sa zvyknú robiť v konštruktore.

\subsubsection{Dôležité metódy}
\begin{itemize}
\item \method{float train(vector<float> input, vector<int> target)}
\\\textit{Backpropagation} algoritmus.
\\ \underline{Vstup:} \textit{input} - vstup siete, \textit{target} - požadované výstupy 
\\ \underline{Výstup:} chyba na danom vstupe.
\item \method{ vector<float> classify(vector<float> input)}
\\ Klasifikačný algoritmus.
\\ \underline{Vstup:} \textit{input} - vstup siete
\\ \underline{Výstup:} pole čísel z~intervalu $(0,1)$ - výstup siete.
\end{itemize}

\subsection{DistributedNeuralNetwork}
Trieda \textit{DistributedNeuralNetwork} dedí z \textit{NeuralNetwork}. Jedinou zmenou je, že ako spodnú vrstvu používa \textit{DistributedNeuralLayer}.

\subsection{RecurrentNetwork}
Trieda \textit{RecurrentNetwork} je potomkom triedy \textit{NeuralNetwork}. Ako spodnú vrstvu používa \textit{RecurrentLayer}. Okrem toho implementuje metódy \method{update()} a \method{reset()}, ktoré updatujú a resetujú rekurentnú vrstvu.

\subsection{DistributedRecurrentNetwork}
Trieda \textit{DistributedRecurrentNetwork} dedí z \textit{RecurrentNetwork}. Ako spodnú vrstvu používa \textit{DistributedRecurrentLayer}.

\section{Triedy pre obrázky}

Pre účely aplikácie potrebujeme špecifickú triedu na obrázky, ktorá spĺňa nasledujúce vlastnosti:
\begin{itemize}
\item Rýchly prístup k~jednotlivým pixlom.
\item Vystrihnutie(crop)
\item Škálovanie
\item Maskovanie
\item Floodfill
\end{itemize}
Okrem toho potrebujeme aby obsahovala aj pomocné metódy, ktoré sú potrebné na niektoré algoritmy a testovanie konverzia do rôznych formátov, ukladanie na disk a~iné.

Trieda \textit{HCImage}, je abstraktná trieda ktorá implementuje základné veci, ktoré sú nezávislé na type pixelu. Od tejto triedy potom dedia triedy \textit{GrayScaleImage} a \textit{ColorImage}. Tieto implementujú metódy, ktoré sú závislé na type pixla. 

%V ďalšom texte sa budeme venovať jednotliv
\subsubsection{Vystrihnutie}
Na vystrihnutie slúži metóda \method{copy(QRect r)}, ktorá berie ako parameter obdĺžnik, ktorého obsah potom vráti ako výsledok. 

\subsubsection{Škálovanie}
Metóda \method{scale(unsigned w, unsigned h)} preškáluje obrázok na novú veľkosť - $w\times h$ pixlov.

Využíva bilineárnu interpoláciu -- vypočíta súradnice nového bodu a pomocou susedných bodov z~pôvodného obrázka vypočíta farbu.

Bilineárna interpolácia má niekoľko výhod. Je stále dosť rýchla, pričom eliminuje kostrbatosť, ktorá môže mať výrazný vplyv pri použití Fourierovej transformácie.

\subsubsection{Maskovanie}

Metóda \method{mask(HCImage *mask, bool invert = false)} aplikuje masku na obrázok. Hodnotu každej farby zníži podľa hodnoty masky v~danom bode.

Maskovanie použijeme na odstránenie nepodstatných častí obrázka, aby neovplyvňovali neurónovú sieť. Využívame bitové operátory na urýchlenie výpočtu. %Každý pixel skombinuje s~pixlom masky. 

\subsubsection{Floodfill selekcia}
Techniku \textit{floodfill selekcie} si môžeme predstaviť ako "čarovnú paličku"\footnote{známu z~grafických programov ako je GIMP, či Photoshop}, alebo nástroj na selekciu susedných pixlov s~podobnými farbami. Techniku \textit{floodfill} používame na získanie masky v~metóde \method{getAdaptiveFloodFillSelectionMask(int sx, int sy, int treshold, float originalFactor, float changeFactor)}. Metóda berie nekoľko parametrov - pozíciu bodu z~ktorého má floodfill začať, hranicu podobnosti farieb, vplyv originálnej farby a zmeny. Referenčná farba sa získa ako priemer začiatočného bodu a jeho okolitých bodov. 

Metóda vráti obrázok, ktorý sa dá použiť ako maska, ktorá odstráni\footnote{začierni} pixle, ktoré neboli vybraté pomocou techniky \textit{floodfill}.

Algortimus funguje ako prehľadávanie do šírky, pričom do susedného pixla pôjde len v~prípade, že ich rozdiel je menší ako hranica. V~prípade farebného obrázka sa tento rozdiel počíta po zložkách a menší musí byť každý z~nich. Pri prejdení do nasledujúceho pixla sa upraví referenčná farba podľa nasledujúceho vzorca: $refcolor = reference \cdot originalFactor + (refcolor\cdot changeFactor+color \cdot (1-changeFactor)) \cdot (1-originalFactor)$, kde $reference$ je začiatočná referenčná farba, $refcolor$ je aktuálna referenčná farba a $color$ je farba pixla.

\section{Získanie obrazu z~webkamery}
Na získanie obrazu z~webkamery používam triedu, ktorá pochádza z~programu \textit{Kapture} \cite{kapture} a ktorú sme upravili pre potreby využitia v~našej aplikácii. Program je šírený pod GNU GPL licenciou.

Webkamera vracia obraz vo formáte MJPEG(Motion JPEG), teda postupnosť obrázkov vo formáte JPEG. Úlohou našej triedy je vždy keď je buffer pripravený, zobrať pretransformovať obrázok do niektorej z~tried na obrázky. JPEG kóduje farby vo formáte YUV, tieto teda musíme pretransformovať do RGB. V~prípade čiernobieleho obrázka iba zoberieme zložku Y.

\section{Spracovanie obrazu}
\label{chap:imageprocess}
\subsection{Trieda ImageProcessor}
Trieda \textit{ImageProcessor} má na starosti predspracovanie obrazu z~webkamery, jeho segmentáciu a posunutie na ďalšie spracovanie triede \textit{HandRecognizer}. \textit{ImageProcessor} využíva vlákna na paralelizáciu úloh a jeho práca je rozdelená do niekoľkých krokov, ktoré nemôžu byť vykonané paralelne. Hlavná metóda je metóda \method{processImage (const GrayScaleImage \&image, const ColorImage \&colorimg)}, ktorá spravuje vlákna a spúšťa jednotlivé kroky. 

Spúštanie vláken je realizované pomocou funkcie \method{QtConcurrent::run(Function function, ...)} z~knižnice \textit{Qt}, ktorá umožňuje spustiť funkciu s~danými parametrami v~novom vlákne. Jednotlivé metódy sú upravené tak, aby vedeli upravovať aj len určitú časť obrázka. Spúšťajú sa v~rôznych vláknach s~rôznymi časťami obrázka. %Kritické časti sme ohraničili mutexami.

\subsubsection{Krok 1: Príprava}
Príprava spočíva vo vytvorení rozdielového obrázka. Pamätáme si pôvodný obrázok a dostaneme nový. Spočítame rozdiel a zapamätaný obrázok potom nahradíme novým.

Na začiatku je pôvodný obrázok celý čierny a v prvom rozdieli toho bude veľa, ale je nízka pravdepodobnosť, že to bude zle vyhodnotené. V prípade zlého vyhodnotenia ale 1 obrázok stále nestačí na gesto.

\subsubsection{Krok 2: Algoritmus rozpitia}
Označíme si dĺžku strany štvorca $k$.

Triviálny algoritmus rozpitia - pre každý pixel vyrobíme okolo neho čierny štvorček - je časovo náročný - má zložitosť $O(k^2.w.h)$. Preto potrebujeme efektívnejší. 
Efektívny algoritmus rozpitia treba robiť v~2 krokoch. Najskôr sa rozpije v~$X$-ovom smere a potom v~$Y$-ovom.

Algoritmus pre $X$-ový smer funguje nasledovne: Ideme postupne po riadkoch a pre každý riadok si pamätáme pokiaľ máme kresliť čiernu.
Na začiatku je to 0. Pozeráme sa vždy o~$\frac{k}{2}$ pixlov ďalej ako kreslíme.
Vždy keď vidíme pixel inej farby ako bielej, tak hranicu pokiaľ máme kresliť čiernu posunieme na hodnotu o~$k$ väčšiu ako je $y$ súradnica pixla ktorý kreslíme. Pokiaľ sme pred hranicou, kreslíme čiernu, inak bielu. Tento algoritmus má zložitosť $O(w.h)$ v~praxi pre $k=11$ asi $5\times$ rýchlejší.  

Keďže riadky sa spracovávajú nezávisle, tak sa dá obrázok rozdeliť na niekoľko častí, ktoré sa dajú spracovať paralelne, čo je ďalšou výhodou efektívnejšieho algoritmu.

Pre $Y$-ový smer je to analogické. 

\subsubsection{Krok 3: Segmentácia}
Ako sme už spomenuli v~kapitole \ref{chap:segment}, obrázok si reprezentujeme ako graf, na ktorý následne použijeme algoritmus prehľadávania do šírky.

Algoritmus postupne spustíme z~každého bodu obrázka, ktorý nie je prázdny a zároveň sme ho predtým ešte žiadnym predošlým behom algoritmu nenavštívili. Každý beh nám vráti obdĺžnik, ktorý ak spĺňa veľkostné obmedzenia, tak je vložený do fronty na ďalšie spracovanie. 

Táto časť je realizovaná len jedným vláknom, keďže obrázok nie je možné vhodne rozdeliť.

\section{Rozpoznanie ruky}

Rozpoznanie ruky má na starosti trieda \textit{HandRecognizer}. Beží naraz v~niekoľkých vláknach - každé vlákno spracováva len jeden segment.
Trieda \textit{HandRecognizer} vyberie z~fronty obdĺžnik čakajúci na spracovanie. Podľa rozmerov a pozície vystrihne príslušnú časť obrázka.

Na vystrihnutý obrázok sa aplikuje fourierova transformácia (kapitola \ref{chap:ft}) a normalizuje sa (kapitola \ref{chap:normalisation}). Výsledok je potom predložený ako vstup neurónovej sieti, ktorá vráti hodnotu $>0,5$ ak to rozpoznala ako ruku, ináč vráti hodnotu $\leq 0,5$. 

\section{Rozpoznanie gesta}
Pokiaľ sme v aktuálnom frame našli ruku, pridáme jej pozíciu do postupnosti a skontrolujeme, či postupnosť netvorí nejaké gesto. Pre každé gesto máme jednoduchú triedu, ktorá ho rozpoznáva. Každá takáto trieda dedí od triedy \textit{Gesture}. Správu gest zastrešuje trieda \textit{GestureRecognizer}

\subsection{GestureRecognizer}

\todo

\subsection{Gesture}

\todo

\section{Simulácia stlačenia kláves}
Knižnica \textit{Xtst} poskytuje funkciu \method{XTestFakeKeyEvent}, ktorá nám umožnuje simulovať stlačenie klávesy. Do nej vložíme pointer na display, kód klávesy, či je stlačená alebo nie(funkciu treba použiť 2x - raz na stlačenie a raz na pustenie klávesy) a aktuálny čas.

\section{Pomocné programy}

\subsubsection{Upravená verzia aplikácie}
\label{chap:saveimageapp}
Upravená verzia aplikácie je kópiou aplikácie, ktorá umožňuje jednoduché ukladanie dát na disk.

Aby sme dostali čo najrealistickejšie obrázky, potrebovali sme aby aplikácia išla takmer tak rýchlo ako pôvodná. Zápis na disk je však časovo náročná operácia, preto sme si obrázky ukladali do buffera a zapisovali dávkovo. Zapisovali sme čo najmenšie množstvo dát, preto sme dáta fourierových transformácií\footnote{kapitola \ref{chap:ft} } robili až dodatočne ďalšou aplikáciou.

\subsubsection{CreateFFT}

\textit{CreateFFT} je program, ktorý umožňuje vytvorenie fourierovej transformácie z~obrázka. Ako parameter berie cestu k~obrázku a vyrobí 2 súbory - normalizovanú fourierovu transformáciu vhodnú pre neurónové siete a obrázok fourierovej transformácie vhodný pre posúdenie človekom.

\todo

\subsubsection{NeuralNet}
%\label{chap:neuralnetapp}
\textit{NeuralNet} je trénovacia aplikácia pre neurónové siete. Využíva rovnaké triedy pre neurónové siete. Obsahuje ľahko upraviteľný algoritmus trénovania a funkcie na jednoduché načítanie dát. 

Dáta máme v~2 oddelených adresároch v~jednom sú dáta zodpovedajúce rukám, a v~druhom ostatné. Programu potom dáme tieto adresáre a on si z~nich vyrobí trénovaciu/testovaciu sadu.

\todo

\subsubsection{Skripty}
Pre zjednodušenie práce sme si napísali rôzne skripty na jednoduché spúštanie trénovania, testovania a na rozdelovanie vstupov do príslušných adresárov.
\todo

\section{Problémy a ich riešenia}
\todo